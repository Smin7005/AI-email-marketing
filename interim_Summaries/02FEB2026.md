# 1. (Campaigns_task 18) Plan: Fix Email Content Preview to Render HTML 

 Problem

 The email content preview on the campaign detail page (/campaigns/[id]) displays raw HTML code instead of rendered formatted text. Users see tags like <p style="margin-bottom: 16px;"> instead of properly formatted paragraphs.

 Root Cause

 - Email content is generated as plain text by the AI
 - It's then converted to HTML with <p> tags and inline styles in src\inngest\functions\generate-emails.ts (lines 267-271)
 - The HTML content is stored in the database's email_content field
 - The campaign detail page displays this content as plain text using {item.emailContent}, which shows the raw HTML tags

 Solution

 Render the HTML content properly in the email preview section using dangerouslySetInnerHTML. This will display the email as it would appear when received.        

 File to Modify

 File: src\app\(dashboard)\campaigns\[id]\page.tsx

 Current code (lines 485-486):
 <div className="p-4 bg-white border border-gray-200 rounded shadow-sm font-mono whitespace-pre-wrap text-sm text-gray-800 min-h-[100px]">
   {item.emailContent || '...'}
 </div>

 Updated code:
 <div
   className="p-4 bg-white border border-gray-200 rounded shadow-sm text-sm text-gray-800 min-h-[100px]"
   dangerouslySetInnerHTML={{
    __html: item.emailContent || '<span class="text-gray-400"> No content available </span>'
   }}
 />

 Changes Summary

 1. Replace {item.emailContent} with dangerouslySetInnerHTML
 2. Remove font-mono and whitespace-pre-wrap classes (not needed for rendered HTML)
 3. Handle empty content case with a styled placeholder

 Verification

 1. Navigate to a campaign detail page with generated emails
 2. Expand an email item to view the content preview
 3. Verify the email displays as formatted text (paragraphs, line breaks) instead of raw HTML tags
 4. Verify the "Copy to Clipboard" button still works correctly

# 2. (Collections_task 4)  Plan: Fix Collections Table to Match Leads Table

 Approach

 Modify CollectionItemsTable independently to match LeadsTable column structure. Keep tables separate to avoid breaking the working Leads page.  

 Problem

 The Collections detail page table (/collections/[id]) has display issues compared to the Leads page table. The main issues are:
 1. Contact column combines email and phone vertically, causing alignment issues
 2. Address column combines suburb, state, postcode into one column
 3. Row selection uses deprecated API
 4. Fixed height instead of auto-height

 Solution

 Refactor CollectionItemsTable.tsx to match the column structure and configuration of LeadsTable.tsx.

 File to Modify

 src\components\collections\CollectionItemsTable.tsx

 Changes

 1. Replace combined "Contact" column with separate "Phone_Number" and "Email" columns

 Current (lines 88-125): Single "Contact" column with vertically stacked email/phone

 New: Two separate columns matching LeadsTable pattern:
 - Phone_Number column (width: 140px)
 - Email column (width: 200px)

 2. Replace combined "Address" column with separate columns

 Current (lines 126-148): Single "Address" column combining suburb, state, postcode

 New: Three separate columns:
 - Detail_Address (suburb) - width: 150px
 - State_Abbreviation (state) - width: 80px
 - Postcode - width: 90px

 3. Update row selection API

 Current (line 264):
 rowSelection="multiple"

 New:
 rowSelection={{
   mode: 'multiRow',
   headerCheckbox: true,
   checkboxes: true,
   enableClickSelection: false
 }}

 4. Remove explicit checkbox column definition

 Current (lines 48-58): Has explicit checkbox column with checkboxSelection: true

 New: Remove this column - let AG Grid handle it via rowSelection config

 5. Update grid layout

 Current (line 257):
 <div className="ag-theme-quartz h-[600px] w-full" style={{ height: '600px', width: '100%' }}>
 With no domLayout prop.

 New:
 <div className="ag-theme-quartz w-full"> Add domLayout="autoHeight" to AgGridReact

 6. Add getRowId for proper row identification

 Add getRowId={(params) => params.data.id} to AgGridReact

 Summary of Column Structure Change
 ┌───────────────────────────┬───────────────────────────────────────┐
 │ Current Collections Table │ New Collections Table (matches Leads) │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Checkbox (explicit)       │ (handled by rowSelection config)      │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Business (250px)          │ Business (200px)                      │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Category (200px)          │ Category (150px)                      │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Contact (250px)           │ Phone_Number (140px)                  │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Address (300px)           │ Email (200px)                         │
 ├───────────────────────────┼───────────────────────────────────────┤
 │ Actions (100px)           │ Detail_Address (150px)                │
 ├───────────────────────────┼───────────────────────────────────────┤
 │                           │ State_Abbreviation (80px)             │
 ├───────────────────────────┼───────────────────────────────────────┤
 │                           │ Postcode (90px)                       │
 ├───────────────────────────┼───────────────────────────────────────┤
 │                           │ Actions (100px)                       │
 └───────────────────────────┴───────────────────────────────────────┘
 Verification

 1. Navigate to Collections page and click on an existing collection
 2. Verify the table displays with separate columns for Phone, Email, Address components
 3. Verify row selection works (checkboxes appear and bulk actions work)
 4. Verify "Remove" action still works
 5. Compare with Leads page table to ensure consistent appearance
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

# 3. (Leads_task 14) Plan: Update Industry Filter to Match Database Category Names

 Problem

 The Leads page industry filter has hardcoded category names that may not match the actual category_name values in the database.

 Current Hardcoded Values (LeadsFilters.tsx)

 - Accountants & Auditors
 - Lawyers & Solicitors
 - Butchers Shop
 - Supermarkets & Grocery Stores
 - Builders & Building Contractors
 - Air Conditioning Installation & Service

 Step 1: SQL Query to Check Database Category Names

 Run this query in Supabase to see all unique category names and their counts:

 SELECT category_name,
 COUNT(*) as count
 FROM rawdata_yellowpage_new
 WHERE category_name IS NOT NULL AND category_name != ''
 GROUP BY category_name
 ORDER BY count DESC
 LIMIT 100;

 To see total distinct categories:
 SELECT COUNT(DISTINCT category_name) as total_categories
 FROM rawdata_yellowpage_new
 WHERE category_name IS NOT NULL AND category_name != '';

 To check if current hardcoded values exist:
 SELECT category_name, COUNT(*) as count
 FROM rawdata_yellowpage_new
 WHERE category_name IN (
   'Accountants & Auditors',
   'Lawyers & Solicitors',
   'Butchers Shop',
   'Supermarkets & Grocery Stores',
   'Builders & Building Contractors',
   'Air Conditioning Installation & Service'
 )
 GROUP BY category_name;

 Step 2: Update Filter Component

 File to Modify:

 src/components/leads/LeadsFilters.tsx

 Current Code (lines 11-19):

 const industryOptions = [
   { value: 'all', label: 'All Industries' },
   { value: 'Accountants & Auditors', label: 'Accountants & Auditors' },
   { value: 'Lawyers & Solicitors', label: 'Lawyers & Solicitors' },
   { value: 'Butchers Shop', label: 'Butchers Shop' },
   { value: 'Supermarkets & Grocery Stores', label: 'Supermarkets & Grocery Stores' },
   { value: 'Builders & Building Contractors', label: 'Builders & Building Contractors' },
   { value: 'Air Conditioning Installation & Service', label: 'Air Conditioning Installation & Service' },
 ];

 Update:

 Replace with the actual category names from the database query results.

 Step 3: Verification

 1. Run SQL queries to get actual category names
 2. Update the industryOptions array with correct values
 3. Test that filtering by each category returns expected results

 ## Follow-up 1:
 The query results show that all 6 current hardcoded category names do exist in the database with these counts:
  ┌─────────────────────────────────────────┬───────┐
  │                Category                 │ Count │
  ├─────────────────────────────────────────┼───────┤
  │ Builders & Building Contractors         │ 7,200 │
  ├─────────────────────────────────────────┼───────┤
  │ Lawyers & Solicitors                    │ 5,552 │
  ├─────────────────────────────────────────┼───────┤
  │ Supermarkets & Grocery Stores           │ 1,988 │
  ├─────────────────────────────────────────┼───────┤
  │ Air Conditioning Installation & Service │ 1,666 │
  ├─────────────────────────────────────────┼───────┤
  │ Butchers Shop                           │ 1,273 │
  ├─────────────────────────────────────────┼───────┤
  │ Accountants & Auditors                  │ 944   │
  └─────────────────────────────────────────┴───────┘
  The current filter values match the database.

# 4. (Campaigns_task 15)  Plan: Persist Campaign Form Data on Navigation

 Problem

 When creating a campaign, users fill out form fields (name, service description, email tone) and select recipients (collections and individual recipients). After clicking "Create Campaign", they are redirected to the campaign detail page. If they click the "Back" button to modify campaign details, all form inputs are reset to empty values because the React component state is lost on unmount.

 Solution

 Use sessionStorage to persist form data temporarily. This approach:
 - Preserves data across page navigation within the same browser tab
 - Automatically clears when the tab is closed (appropriate for temporary form data)
 - Requires no additional dependencies
 - Is simple to implement

 Files to Modify

 1. src/app/(dashboard)/campaigns/create/page.tsx - Add sessionStorage logic for all form state
 2. src/components/campaigns/CampaignForm.tsx - Accept initial values and notify parent of changes

 Implementation Details

 1. CampaignForm.tsx Changes

 - Add initialValues prop to accept pre-filled form data
 - Add onChange callback prop to notify parent when form values change
 - Use initialValues in useForm defaultValues instead of empty strings
 - Call onChange when any field value changes

 2. create/page.tsx Changes

 - Define a sessionStorage key constant: CAMPAIGN_DRAFT_KEY
 - On component mount (useEffect):
   - Load saved draft from sessionStorage if it exists
   - Restore form data, selectedCollections, and individualRecipients
 - On form field changes:
   - Save updated state to sessionStorage
 - On recipient selection changes:
   - Save updated state to sessionStorage
 - On successful campaign creation:
   - Clear sessionStorage to prevent stale data on next visit
 - Pass initialValues and onChange to CampaignForm

 Data Structure for sessionStorage

 interface CampaignDraft {
   formData: {
     name: string;
     serviceDescription: string;
     emailTone: string;
   };
   selectedCollections: SelectedCollection[];
   individualRecipients: IndividualRecipient[];
 }

 Verification

 1. Navigate to /campaigns/create
 2. Fill in campaign name, service description, and email tone
 3. Select a collection or add individual recipients
 4. Click "Create Campaign"
 5. On the campaign detail page, click "Back"
 6. Verify all previously entered values are restored
 7. Create the campaign successfully
 8. Navigate to /campaigns/create again
 9. Verify the form is empty (draft was cleared after successful creation)

  ## Follow-up 1:
  Summary: Fixing React Error #185  
  The Error React error #185 is "Maximum update depth exceeded" - an infinite re-render loop.
  
  Root Cause

  In CampaignForm.tsx, I initially used form.watch() to observe all form values:

  // PROBLEMATIC CODE
  const watchedValues = form.watch();
  useEffect(() => {
    if (onChange) {
      onChange(watchedValues);
    }
  }, [watchedValues, onChange]);

  form.watch() returns a new object reference on every render, even if the values inside are the same. This caused:

  1. Component renders → watchedValues is a new object
  2. useEffect fires because dependency changed
  3. onChange is called → parent state updates
  4. Parent re-renders → CampaignForm re-renders
  5. watchedValues is a new object again → repeat infinitely

  The Fix

  Watch individual fields instead, which return primitive strings:

  // FIXED CODE
  const watchedName = form.watch('name');
  const watchedServiceDescription = form.watch('serviceDescription');
  const watchedEmailTone = form.watch('emailTone');

  useEffect(() => {
    if (onChange) {
      onChange({
        name: watchedName,
        serviceDescription: watchedServiceDescription,
        emailTone: watchedEmailTone,
      });
    }
  }, [watchedName, watchedServiceDescription, watchedEmailTone, onChange]);

  Primitive strings are compared by value, so the useEffect only fires when the actual form content changes.

  Additional Fix

  Also delayed rendering CampaignForm until isDraftLoaded is true, ensuring the form mounts with correct initial values from sessionStorage rather than needing to reset mid-render.
  
  ## Follow-up 2:
  Problem: The draft was being cleared immediately after campaign creation (clearDraft() was called), so clicking "Back" showed empty form.       
  
  Solution:
  1. Removed clearDraft() after campaign creation - Now the draft persists when you click Back
  2. Added ?new=true parameter to "Create New Campaign" links in:
    - src/app/(dashboard)/campaigns/page.tsx
    - src/components/dashboard/DashboardTutorial.tsx
  3. Updated create page to check for this parameter and only clear the draft when starting a fresh campaign

  New Behavior:
  - Click "Back" from campaign detail page → Form data is restored
  - Click "Create New Campaign" button → Form is empty (fresh start)

  Please test the workflow:
  1. Fill in the form and create a campaign
  2. Click "Back" on the campaign detail page
  3. Your form data should now be restored

  ## Follow-up 3:
  Plan: Fix Vercel Build Error - useSearchParams Suspense Boundary

  Problem

  The Vercel build fails with:
  useSearchParams() should be wrapped in a suspense boundary at page "/campaigns/create"

  This error was introduced when useSearchParams() was added to detect the ?new=true query parameter for clearing the campaign draft.
  
  Root Cause

  In Next.js 14, useSearchParams() causes a client-side rendering bailout during static generation. The page must be wrapped in a Suspense boundary to handle this.
  
  Solution

  Wrap the CreateCampaignPage component content in a Suspense boundary, or split it into a wrapper component that handles the Suspense.
  
  File to Modify

  src/app/(dashboard)/campaigns/create/page.tsx

  Implementation

  1. Import Suspense from React
  2. Create an inner component CreateCampaignContent that contains all the current logic (including useSearchParams)        
  3. Export a wrapper component that renders CreateCampaignContent inside a <Suspense> boundary with a loading fallback     

  import { Suspense } from 'react';

   function CreateCampaignContent() {
    // All current component logic here, including useSearchParams
   }

   export default function CreateCampaignPage() {
    return (
      <Suspense fallback={<LoadingSpinner />}>
        <CreateCampaignContent />
      </Suspense>
    );
   }

  Verification

  1. Run npm run build locally - should complete without errors
  2. Run vercel --prod - should deploy successfully

  ## Follow-up 4:
    Problem

    Vercel deployment still fails even though the local build succeeds.

    Root Cause

    The Suspense fix has been applied locally but not committed to git. When running vercel --prod, Vercel builds from the git repository, not local files.
    
    Evidence:
    git status shows:
    modified: src/app/(dashboard)/campaigns/create/page.tsx (not staged)

    Last commit: fb2272d Follow-up Persist Campaign Form Data on Navigation

    The Suspense boundary fix is only in local files.

    Solution

    Commit and push the changes to git so Vercel can deploy them.

    Steps

    1. Stage the modified file: git add src/app/(dashboard)/campaigns/create/page.tsx
    2. Commit: git commit -m "Fix useSearchParams Suspense boundary for Next.js build"
    3. Push: git push
    4. Deploy: vercel --prod (or wait for automatic deployment)

    Verification

    After pushing, the Vercel deployment should succeed without the useSearchParams error.
    
    ## Follow-up 5: 
        Problem

        When clicking "Back" from the campaign detail page, the form inputs are null/empty instead of showing the saved draft.    

        Root Cause

        When user navigates:
        1. From campaigns list → clicks "Create New Campaign" → goes to /campaigns/create?new=true
        2. Fills form, clicks "Create Campaign" → redirected to /campaigns/123
        3. Clicks "Back" → browser history goes back to /campaigns/create?new=true
        4. Bug: The ?new=true parameter triggers draft clearing, so form is empty!

        The ?new=true parameter persists in browser history, so clicking "Back" always clears the draft.

        Solution

        After clearing the draft when ?new=true is detected, replace the URL to remove the query parameter. This way, if the user navigates back later, the URL will be /campaigns/create (without ?new=true) and the draft will be preserved.

        File to Modify

        src/app/(dashboard)/campaigns/create/page.tsx

        Implementation

        In the useEffect that handles isNewCampaign, after clearing the draft, use router.replace('/campaigns/create') to remove the ?new=true from the URL:

        if (isNewCampaign) {
        try {
            sessionStorage.removeItem(CAMPAIGN_DRAFT_KEY);
        } catch (error) {
            console.error('Error clearing draft from sessionStorage:', error);
        }
        // Remove ?new=true from URL so "Back" navigation won't clear draft again
        router.replace('/campaigns/create');
        setIsDraftLoaded(true);
        return;
        }

        Verification

        1. Click "Create New Campaign" from campaigns list
        2. Fill in form details
        3. Click "Create Campaign"
        4. On campaign detail page, click "Back"
        5. Form should show previously entered values 
