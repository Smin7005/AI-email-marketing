# 1. Fix searching filter on Leads page.
 Plan: Analyze category_name vs industry_name Relationship

 Objective

 Query the Supabase database to determine the hierarchical relationship between category_name and industry_name columns in the rawdata_yellowpage_new table.       

 Current Understanding

 - category_name: 1,054 distinct values (fine-grained)
 - industry_name: 113 distinct values (broader)
 - The application currently only uses category_name (mapped as "industry" in the code)
 - industry_name exists in the database but is unused

 Analysis Queries to Run

 Query 1: Check data population

 SELECT
   COUNT(*) as total_records,
   COUNT(category_name) as has_category,
   COUNT(industry_name) as has_industry,
   COUNT(CASE WHEN category_name IS NOT NULL AND industry_name IS NOT NULL THEN 1 END) as has_both
 FROM rawdata_yellowpage_new;

 Query 2: Analyze category-to-industry mapping

 SELECT
   category_name,
   industry_name,
   COUNT(*) as record_count
 FROM rawdata_yellowpage_new
 WHERE category_name IS NOT NULL AND industry_name IS NOT NULL
 GROUP BY category_name, industry_name
 ORDER BY category_name, industry_name
 LIMIT 100;

 Query 3: Count industries per category (determines if category -> industry is one-to-one or one-to-many)

 SELECT
   category_name,
   COUNT(DISTINCT industry_name) as industry_count
 FROM rawdata_yellowpage_new
 WHERE category_name IS NOT NULL AND industry_name IS NOT NULL
 GROUP BY category_name
 HAVING COUNT(DISTINCT industry_name) > 1
 ORDER BY industry_count DESC
 LIMIT 20;

 Query 4: Count categories per industry (determines if industry is the parent)

 SELECT
   industry_name,
   COUNT(DISTINCT category_name) as category_count
 FROM rawdata_yellowpage_new
 WHERE category_name IS NOT NULL AND industry_name IS NOT NULL
 GROUP BY industry_name
 ORDER BY category_count DESC
 LIMIT 20;

 Implementation Approach

 Create a simple script or API endpoint to run these queries using the existing getCompanyDbClient() function from src/lib/db/supabase.ts.

 Option A: Create a temporary API route (Recommended)

 Create src/app/api/analyze-data/route.ts that runs these queries and returns results.

 Option B: Run directly in Supabase Dashboard

 Use the Supabase SQL Editor to run these queries directly.

 Expected Outcomes

 After running these queries, we will know:
 1. Whether both fields are populated for all/most records
 2. If one category maps to one industry (1:1) or multiple (1:many)
 3. If one industry contains multiple categories (parent-child relationship)
 4. The exact hierarchical structure

Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| src/app/api/analyze-data/route.ts | Create | Temporary API to run analysis queries |
 Verification

 - Call the API endpoint: GET /api/analyze-data
 - Review the JSON response to understand the relationship
 - Delete the temporary file after analysis is complete

    ## Follow-up 1:
    This changes the picture significantly. The relationship is MANY-TO-MANY, not a simple parent-child hierarchy.

    industry_name ←──── MANY-TO-MANY ────→ category_name
    
### Evidence

| Direction | Finding |
|-----------|---------|
| Industry → Categories | 1 industry contains up to 63 categories |
| Category → Industries | 1 category belongs to up to 15 industries |
### Examples of Categories in Multiple Industries

| Category | Belongs to # Industries |
|----------|------------------------|
| Excavation & Earthmoving Contractors | 15 industries |
| Building Supplies | 13 industries |
| Builders & Building Contractors | 11 industries |
| Doctors-Medical Practitioners | 10 industries |
  What This Means

  The two columns are not strictly hierarchical. They represent two different classification dimensions that overlap:

  - industry_name: Broader business type (113 values)
  - category_name: Specific service/product offered (1,054 values)

  A single business record can have a category_name that logically fits under multiple industry_name groupings. For example, "Kitchen Renovations & Designs" could reasonably fall under:
  - Builders & Building Contractors
  - Home Maintenance & Handymen
  - Cabinet Makers & Designers
  - etc.

  Practical Implication

  For your application's filtering:
  - You cannot use industry as a strict parent filter (selecting industry then showing only its categories)
  - They should be treated as independent filters or
  - You could create a curated mapping table that defines one canonical industry per category

  Would you like me to help design a filtering strategy that works with this many-to-many relationship?

## Follow-up 2: Plan - Add Category Groups to Leads Filter

### Objective

1. Divide 1,054 category_name values into 15 logical groups
2. Add category_group column to rawdata_yellowpage_new table in Supabase
3. Update Leads page filter to use the new column

---

### Phase 1: Proposed 15 Category Groups

Based on analysis of the 1,054 categories, here are the proposed groups:

| # | Group Name | Example Categories |
|---|------------|-------------------|
| 1 | Construction & Building | Builders, Bricklayers, Carpenters, Concrete Contractors, Roofing |
| 2 | Trades & Home Services | Plumbers, Electricians, Painters, Locksmiths, Home Maintenance |
| 3 | Automotive | Mechanics, Panel Beaters, Car Parts, Tyres, Auto Electricians |
| 4 | Healthcare & Medical | Doctors, Dentists, Hospitals, Medical Centres, Pathology, Vets |
| 5 | Allied Health & Wellness | Physiotherapists, Chiropractors, Massage, Naturopaths, Psychologists |
| 6 | Beauty & Personal Care | Hairdressers, Beauty Salons, Day Spas, Barbers |
| 7 | Food & Hospitality | Restaurants, Cafes, Butchers, Bakeries, Catering |
| 8 | Retail & Shopping | Department Stores, Gift Shops, Clothing, Furniture Stores |
| 9 | Professional Services | Accountants, Lawyers, Consultants, Financial Planning |
| 10 | Real Estate & Property | Real Estate, Conveyancers, Building Surveyors, Property Consultants |
| 11 | Transport & Logistics | Freight, Couriers, Taxi, Towing, Removalists |
| 12 | Agriculture & Rural | Farmers, Livestock, Farm Supplies, Graziers |
| 13 | Education & Training | Schools, Driving Schools, Business Colleges, Training |
| 14 | Entertainment & Recreation | Cinemas, Sports, Music, Wedding Services, Party Hire |
| 15 | Industrial & Manufacturing | Engineering, Mining, Welding, Metal Fabrication |

---

### Phase 2: Database Changes

**Step 2.1: Add new column to Supabase**

Run in Supabase SQL Editor:

```sql
ALTER TABLE rawdata_yellowpage_new
ADD COLUMN category_group VARCHAR(50);
```

**Step 2.2: Create mapping and update data**

Create a SQL script that maps each category_name to its group. Example:

```sql
UPDATE rawdata_yellowpage_new
SET category_group = 'Construction & Building'
WHERE category_name IN (
  'Builders & Building Contractors',
  'Bricklayers',
  'Carpenters & Joiners',
  'Concrete Contractors'
  -- ... more categories
);

UPDATE rawdata_yellowpage_new
SET category_group = 'Trades & Home Services'
WHERE category_name IN (
  'Plumbers & Gas Fitters',
  'Electricians & Electrical Contractors',
  'Painters & Decorators'
  -- ... more categories
);
-- Repeat for all 15 groups
```

**Step 2.3: Add index for query performance**

```sql
CREATE INDEX idx_category_group ON rawdata_yellowpage_new(category_group);
```

---

### Phase 3: Code Changes

**File 1: src/components/leads/LeadsFilters.tsx**

Replace hardcoded industries array with 15 category groups:

```typescript
const categoryGroups = [
  { value: 'all', label: 'All Categories' },
  { value: 'Construction & Building', label: 'Construction & Building' },
  { value: 'Trades & Home Services', label: 'Trades & Home Services' },
  { value: 'Automotive', label: 'Automotive' },
  { value: 'Healthcare & Medical', label: 'Healthcare & Medical' },
  { value: 'Allied Health & Wellness', label: 'Allied Health & Wellness' },
  { value: 'Beauty & Personal Care', label: 'Beauty & Personal Care' },
  { value: 'Food & Hospitality', label: 'Food & Hospitality' },
  { value: 'Retail & Shopping', label: 'Retail & Shopping' },
  { value: 'Professional Services', label: 'Professional Services' },
  { value: 'Real Estate & Property', label: 'Real Estate & Property' },
  { value: 'Transport & Logistics', label: 'Transport & Logistics' },
  { value: 'Agriculture & Rural', label: 'Agriculture & Rural' },
  { value: 'Education & Training', label: 'Education & Training' },
  { value: 'Entertainment & Recreation', label: 'Entertainment & Recreation' },
  { value: 'Industrial & Manufacturing', label: 'Industrial & Manufacturing' },
];
```

**File 2: src/app/(dashboard)/leads/page.tsx**

Change line 49 - Update query to filter by category_group instead of category_name:

```typescript
// Before:
query = query.eq('category_name', industryQuery.trim());

// After:
query = query.eq('category_group', industryQuery.trim());
```

---

### Phase 4: Implementation Order

1. Create the full SQL mapping script (categorize all 1,054 categories)
2. Run ALTER TABLE to add column
3. Run UPDATE statements to populate data
4. Add index
5. Update LeadsFilters.tsx
6. Update page.tsx
7. Test filtering works correctly

---

### Files to Modify

| File | Changes |
|------|---------|
| src/components/leads/LeadsFilters.tsx | Replace industries array with 15 category groups |
| src/app/(dashboard)/leads/page.tsx | Change filter query from category_name to category_group |
| Supabase (SQL) | Add column, populate data, add index |

---

### Verification

1. Run SQL query to confirm all records have category_group populated:
   ```sql
   SELECT category_group, COUNT(*) FROM rawdata_yellowpage_new GROUP BY category_group;
   ```
2. Test the Leads page filter with each of the 15 groups
3. Verify results match expected categories within each group

 ## Follow-up 3:  I've created the SQL script at supabase/add_category_group.sql.

  Next Steps

  Step 1: Run the SQL in Supabase Dashboard

  Copy and paste the contents of supabase/add_category_group.sql into the Supabase SQL Editor and run it. This will:
  1. Add the category_group column
  2. Assign all 1,054 categories to their groups
  3. Create an index for performance
  4. Show you the distribution count at the end

  Step 2: Verify the results

  After running, you should see output like:
  category_group              | count
  ----------------------------|-------
  Retail & Shopping           | xxx
  Trades & Home Services      | xxx
  Construction & Building     | xxx
  ...

  Let me know once you've run the SQL successfully, and I'll update the frontend code (LeadsFilters.tsx and page.tsx) to use the new category_group column.       

## Follow-up 4: I've split the SQL into 16 smaller files in supabase/category_group_updates/. Run them one at a time in Supabase SQL Editor:

### Files to Run (in order)

| File | Group |
|------|-------|
| 01_construction.sql | Construction & Building |
| 02_trades.sql | Trades & Home Services |
| 03_automotive.sql | Automotive |
| 04_healthcare.sql | Healthcare & Medical |
| 05_allied_health.sql | Allied Health & Wellness |
| 06_beauty.sql | Beauty & Personal Care |
| 07_food.sql | Food & Hospitality |
| 08_retail.sql | Retail & Shopping |
| 09_professional.sql | Professional Services |
| 10_realestate.sql | Real Estate & Property |
| 11_transport.sql | Transport & Logistics |
| 12_agriculture.sql | Agriculture & Rural |
| 13_education.sql | Education & Training |
| 14_entertainment.sql | Entertainment & Recreation |
| 15_industrial.sql | Industrial & Manufacturing |
| 16_other_and_index.sql | Catch-all + Index |

  Since you already have the column created and some data populated, you can skip any groups that already ran successfully. After running all files, file 16 will assign "Other" to any remaining nulls and create the index.

  Let me know when you've finished running the SQL scripts, and I'll update the frontend code.

  ## Follow-up 5: Good idea. Run these queries in Supabase to check the current state:     
  
  Query 1: Count populated vs empty 
  SELECT
    COUNT(*) as total_rows,                                                                                                                                        
    COUNT(category_group) as populated,
    COUNT(*) - COUNT(category_group) as still_null
  FROM rawdata_yellowpage_new;

  Query 2: See which groups are already populated
  SELECT
    category_group,
    COUNT(*) as count
  FROM rawdata_yellowpage_new
  WHERE category_group IS NOT NULL
  GROUP BY category_group
  ORDER BY category_group;

  Query 3: Sample of categories still without a group
  SELECT DISTINCT category_name
  FROM rawdata_yellowpage_new
  WHERE category_group IS NULL
  ORDER BY category_name
  LIMIT 50;

  Run these and share the results - I'll tell you which SQL files you still need to run. 

  ## Follow-up 6: All code changes are complete. Here's what was updated:

  Changes Made 
  
  src/components/leads/LeadsFilters.tsx
  
  - Replaced 7 hardcoded industries with 17 category groups (15 groups + "All" + "Other")
  - Groups are sorted by popularity (most leads first)

  src/app/(dashboard)/leads/page.tsx
  - Added category_group to the Company interface
  - Added category_group to the SELECT query
  - Changed filter from category_name to category_group
  - Updated active filter label from "Industry" to "Category"

  Test the Changes

  1. Start the dev server: npm run dev
  2. Navigate to the Leads page
  3. Test the dropdown - you should see 17 options
  4. Select a category group and verify the results filter correctly

# 2. Research Multi-Tenant Email Sending Implementation

## Objective

Allow platform users to send emails from their own custom domains instead of the platform's default domain. This enables white-label email campaigns and improves deliverability for organizations with established domain reputation.

## Current State

The platform currently uses Resend with a single API key. The `sender_email` field exists in the `campaigns` table but is not used - the code in `send-emails.ts:329` overrides it with `process.env.FROM_EMAIL`.

## Email Service Provider Comparison (Updated Feb 5, 2026)

| Provider | Plan | Price/mo | Emails/mo | Domains | Extra Emails | Programmatic Domain API |
|----------|------|----------|-----------|---------|--------------|------------------------|
| **Resend** | Free | $0 | 3,000 | 1 | - | No |
| | Pro | $20 | 50,000 | 10 | $0.90/1K | No |
| | Scale | $90 | 100,000 | 1,000 | $0.90/1K | No |
| **Postmark** | Basic | $15 | 10,000 | 5 | $1.80/1K | Yes |
| | Pro | $16.50 | 10,000 | 10 | $1.30/1K | Yes |
| | Platform | $18 | 10,000 | Unlimited | $1.20/1K | Yes |
| **SendGrid** | Basic | $15 | 300,000 | varies | varies | Yes |
| | Advanced | $60 | 1,000,000 | varies | varies | Yes |
| **Mailgun** | Free | $0 | 100/day | 1 | - | Yes |
| | Basic | $15 | 10,000 | 1 | $1.80/1K | Yes |
| | Foundation | $35 | 50,000 | 1,000 | $1.30/1K | Yes |
| | Scale | $90 | 100,000 | unlimited | $1.10/1K | Yes |
| **AWS SES** | Pay-as-you-go | ~$0 | - | unlimited | $0.10/1K | Yes |

## Key Findings

**For Multi-Tenant Email Marketing Platform:**

1. **Postmark** - Prohibits marketing/cold email (transactional only) - DISQUALIFIED
2. **Resend** - No programmatic domain API; domains must be added manually via dashboard - NOT IDEAL for self-service
3. **Mailgun Foundation ($35/mo)** - Best balance: 1,000 domains, full API support, marketing allowed
4. **SendGrid** - Enterprise subuser model, complex API key management per tenant
5. **AWS SES** - Cheapest at scale but highest operational complexity (SNS setup for events)

## Recommendation

**Mailgun Foundation** is recommended for multi-tenant implementation:
- 1,000 custom sending domains (sufficient for growth)
- Full programmatic domain API with webhooks
- Marketing email allowed
- $35/month base cost
- $1.30/1K extra emails

## Architecture Decision: Dual Provider Approach

Use a **dual provider** strategy:
- **Resend** (current): Default sender for organizations without custom domains
- **New provider** (TBD): For organizations with their own verified domains

This allows gradual migration and keeps existing functionality stable.

## Next Steps (When Ready to Implement)

1. Select email provider (Mailgun Foundation recommended)
2. Design database schema for domain management
3. Build domain verification UI (self-service)
4. Create provider abstraction layer
5. Update email sending to use org's domain when available

### Follow-up 1: Provider Pros and Cons

**Resend**
- Pros: 
 1. Excellent TypeScript SDK and developer experience
 2. Already integrated in current codebase
 3. Simple, clean API with good documentation
- Cons: 
 1. No programmatic domain API (manual dashboard setup)
 2. Single account model with no tenant isolation 
 3. All emails share same IP reputation

**Postmark**
- Pros: 
 1. Industry-leading deliverability rates
 2. Unlimited domains on Platform tier ($18/mo)
 3. Real-time DNS verification via API
- Cons: 
 1. Prohibits marketing/cold email (transactional only)
 2. Higher cost per 1,000 emails ($1.20-$1.80)
 3. Limited to ~100 servers per account

**SendGrid**
- Pros: 
 1. Enterprise-grade subuser system for multi-tenant
 2. Isolated IP reputation per subuser
 3. High volume capacity (1M+ emails/mo)
- Cons: 
 1. Complex permission and API key management per tenant
 2. Higher learning curve than alternatives
 3. IP warmup required for new subusers

**Mailgun**
- Pros: 
 1. 1,000 custom domains on Foundation tier 
 2. Full programmatic domain API with webhooks
 3. Subdomain delegation for easy customer setup
- Cons: 
 1. Requires webhook infrastructure for domain verification
 2. Domain deletion has safety delays
 3. Some features require higher-tier plans

**AWS SES**
- Pros: 
 1. Extremely cost-effective ($0.10/1K emails)
 2. Unlimited domains with full API support
 3. Scales to massive volumes
- Cons: 
 1. Highest operational complexity (SNS, IAM setup)
 2. 24-72 hour domain verification time
 3. Shared IP reputation (dedicated IPs cost extra)

