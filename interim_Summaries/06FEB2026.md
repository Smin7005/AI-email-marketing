# 1. Implementation plan of epic: Multi-tenant email sending services

## Overview

Implement multi-tenant email sending via AWS SES, allowing organizations to verify their own sending domains. Organizations with verified domains use AWS SES; those without use the existing Resend integration (website's default domain).

**Current State:** Email sending uses Resend API (src/lib/email/resend.ts). AWS SES SDK is already installed but unused.

**Key Decisions:**
- **Fallback:** Organizations without verified domains use Resend (website's default domain)
- **AWS Region:** ap-southeast-1 (Singapore) as default
- **Auto-verification:** Background job to automatically check pending domain status

---

## User Story 1: Allow User to Input Required DNS Details

### UI Design (Resend-style)

**1.0 Navigation Entry Point**
- Add button at bottom of Analytics page to navigate to Senders page

**1.1 Senders Page - Default Layout**

**Header:** "Senders" title on left, "+ Add sender" button on right

**Table:**
| Email Address | Status | Created | Actions |
|---------------|--------|---------|---------|
| user@example.com | Verified | 12 minutes ago | ⋮ |

**Footer:** "Page 1 - 1 of 1 senders"

**Notes:**
- Actions menu (⋮) opens dropdown with "Delete" option
- Status badge: green "Verified" or yellow "Pending"

**1.2 Add Sender - 2-Step Onboarding Flow**

**Step 1: Email Input**
- Header: "Which email address you prefer to use?"
- Input field for email address
- "Add Sender" button to proceed to Step 2

**Step 2: DNS Records Display**
- Get TXT/CNAME values from AWS SES API
- Display DNS records in table format
- Instructions: "Add these records to your Cloudflare DNS settings"
- Records to display:
  - Domain verification TXT record
  - 3 DKIM CNAME records

### Tasks

**1.1 Database Schema - Add senders table**
- File: `src/lib/db/schema.ts`
- Add new table `senders` with fields:
  - `id`, `organization_id`, `email_address`, `domain`
  - `verification_status` (pending/verifying/verified/failed)
  - `verification_token` (from AWS)
  - `dkim_tokens` (JSONB array of 3 tokens)
  - `dkim_status`
  - `is_default`, `last_verified_at`
  - `verification_error` (text, stores failure reason)
  - `configuration_set_name` (for SES tracking)
  - `created_at`, `updated_at`
- Create migration file in `src/lib/db/migrations/`

**1.2 Create AWS SES Service**
- New file: `src/lib/email/ses.ts`
- Implement SESClient wrapper with methods:
  - `verifyDomainIdentity(domain)` - returns verification token
  - `verifyDomainDkim(domain)` - returns 3 DKIM tokens
  - `getIdentityVerificationAttributes(identities)`
  - `getIdentityDkimAttributes(identities)`
  - `deleteIdentity(domain)`
  - `getSendQuota()` - get account sending limits
  - `getAccountStatus()` - check sandbox vs production

**1.3 Create Sender Verification Service**
- New file: `src/lib/services/sender-verification.ts`
- Methods: `addSender()`, `listSenders()`, `getDnsRecords()`, `removeSender()`, `setDefaultSender()`
- Include email/domain format validation
- Include rate limiting check (max 5 pending per org)

**1.4 API Routes for Sender Management**
- `src/app/api/senders/route.ts` - GET (list), POST (create)
- `src/app/api/senders/[id]/route.ts` - GET (details), DELETE

**1.5 UI Components**
- `src/components/senders/SendersPage.tsx` - Main page with table layout
- `src/components/senders/SenderTable.tsx` - Table with Email Address, Status, Created columns
- `src/components/senders/AddSenderDialog.tsx` - 2-step onboarding flow
- `src/components/senders/DnsRecordsDisplay.tsx` - Show DNS records for Cloudflare

**1.6 Senders Page**
- New page: `src/app/(dashboard)/senders/page.tsx`
- Resend-style layout with table view
- Add navigation button from Analytics page

### Detailed Implementation Plan for Story 1

#### Step 1.1: Database Schema (Est. file changes: 2)
```
Files to modify:
- src/lib/db/schema.ts (add senders table definition)
- src/lib/db/migrations/XXXX_add_senders.sql (new file)

Schema definition:
export const senders = pgTable('senders', {
  id: serial('id').primaryKey(),
  organizationId: varchar('organization_id').notNull(),
  emailAddress: varchar('email_address', { length: 255 }).notNull(),
  domain: varchar('domain', { length: 255 }).notNull(), // extracted from email
  verificationStatus: varchar('verification_status', { length: 50 }).default('pending').notNull(),
  verificationToken: varchar('verification_token', { length: 255 }),
  dkimTokens: jsonb('dkim_tokens').$type<string[]>(),
  dkimStatus: varchar('dkim_status', { length: 50 }).default('not_started'),
  isDefault: boolean('is_default').default(false),
  lastVerifiedAt: timestamp('last_verified_at'),
  verificationError: text('verification_error'),
  configurationSetName: varchar('configuration_set_name', { length: 255 }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  orgIdx: index('senders_org_idx').on(table.organizationId),
  emailIdx: index('senders_email_idx').on(table.emailAddress),
  uniqueEmailPerOrg: unique().on(table.organizationId, table.emailAddress),
}));

Run: npx drizzle-kit generate:pg && npx drizzle-kit push:pg
```

#### Step 1.2: AWS SES Service (Est. file changes: 1)
```
Files to create:
- src/lib/email/ses.ts

Key imports:
import { SESClient, VerifyDomainIdentityCommand, VerifyDomainDkimCommand,
         GetIdentityVerificationAttributesCommand, GetIdentityDkimAttributesCommand,
         DeleteIdentityCommand, GetSendQuotaCommand, GetAccountSendingEnabledCommand,
         SendEmailCommand } from '@aws-sdk/client-ses';

Class structure:
export class SESService {
  private client: SESClient;
  private region: string;

  constructor(region?: string) {
    this.region = region || process.env.AWS_SES_REGION || 'ap-southeast-1';
    this.client = new SESClient({
      region: this.region,
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
      },
    });
  }

  async verifyDomainIdentity(domain: string): Promise<{ verificationToken: string }> { ... }
  async verifyDomainDkim(domain: string): Promise<{ dkimTokens: string[] }> { ... }
  async getIdentityVerificationAttributes(identities: string[]): Promise<Map<string, VerificationAttributes>> { ... }
  async getIdentityDkimAttributes(identities: string[]): Promise<Map<string, DkimAttributes>> { ... }
  async deleteIdentity(domain: string): Promise<void> { ... }
  async getSendQuota(): Promise<SendQuota> { ... }
  async isInSandbox(): Promise<boolean> { ... }
}

export const sesService = new SESService();
```

#### Step 1.3: Sender Verification Service (Est. file changes: 1)
```
Files to create:
- src/lib/services/sender-verification.ts

Key functions:
export class SenderVerificationService {
  // Validate email format and extract domain
  private validateEmail(email: string): { valid: boolean; domain?: string; error?: string } {
    // Check email format, extract domain part
  }

  // Check rate limit (max 5 pending per org)
  private async checkRateLimit(organizationId: string): Promise<boolean> { ... }

  // Add new sender - calls SES APIs with extracted domain
  async addSender(organizationId: string, emailAddress: string): Promise<Sender> {
    // 1. Validate email format
    // 2. Extract domain from email (e.g., "user@example.com" -> "example.com")
    // 3. Check rate limit
    // 4. Check if sender already exists for org
    // 5. Call sesService.verifyDomainIdentity(domain)
    // 6. Call sesService.verifyDomainDkim(domain)
    // 7. Insert into database with email_address, domain, and tokens
    // 8. Return sender with DNS records
  }

  // Get DNS records for display (for Cloudflare)
  getDnsRecords(sender: Sender): DnsRecord[] {
    // Return formatted TXT and CNAME records
  }

  // List senders for organization
  async listSenders(organizationId: string): Promise<Sender[]> { ... }

  // Remove sender
  async removeSender(organizationId: string, senderId: number): Promise<void> {
    // 1. Check no active campaigns using sender
    // 2. Delete from SES
    // 3. Delete from database
  }

  // Set default sender
  async setDefaultSender(organizationId: string, senderId: number): Promise<void> {
    // 1. Unset current default
    // 2. Set new default
  }
}

export const senderVerificationService = new SenderVerificationService();
```

#### Step 1.4: API Routes (Est. file changes: 2)
```
Files to create:
- src/app/api/senders/route.ts
- src/app/api/senders/[id]/route.ts

Route: GET /api/senders
- Auth check via Clerk
- Get organization_id
- Return senderVerificationService.listSenders(organizationId)

Route: POST /api/senders
- Auth check
- Validate body: { emailAddress: string }
- Zod schema: z.object({ emailAddress: z.string().email() })
- Return senderVerificationService.addSender(organizationId, emailAddress)

Route: GET /api/senders/[id]
- Auth check
- Get sender by ID with org check
- Include DNS records in response

Route: DELETE /api/senders/[id]
- Auth check
- Check sender belongs to org
- Check no active campaigns using this sender
- Call senderVerificationService.removeSender()
```

#### Step 1.5: UI Components (Est. file changes: 4)
```
Files to create:
- src/components/senders/SenderTable.tsx
- src/components/senders/AddSenderDialog.tsx
- src/components/senders/DnsRecordsDisplay.tsx
- src/components/senders/VerificationStatus.tsx

SenderTable (Resend-style):
- Table header: Email Address | Status | Created
- Table rows with: checkbox, globe icon, email, status badge, timestamp, action menu
- Empty state: "No senders yet. Click '+ Add sender' to get started"
- Pagination: "Page X - Y of Z senders - N items"

AddSenderDialog (2-Step Onboarding Flow):
Step 1:
  - Header: "Which email address you prefer to use?"
  - Email input field with validation
  - "Add Sender" button to proceed
Step 2:
  - Header: "Configure DNS Records"
  - Instructions: "Add these records to your Cloudflare DNS settings"
  - DnsRecordsDisplay component showing TXT and CNAME records
  - Copy buttons for each record value
  - "Done" button to close dialog

DnsRecordsDisplay:
- Table showing DNS records for Cloudflare:
  - Domain verification TXT record
  - 3 DKIM CNAME records
- Copy-to-clipboard button for each value
- Status indicator per record (pending/verified)

VerificationStatus:
- Badge variants: pending (yellow), verified (green), failed (red)
```

#### Step 1.6: Senders Page (Est. file changes: 2)
```
Files to create:
- src/app/(dashboard)/senders/page.tsx

Files to modify:
- src/app/(dashboard)/analytics/page.tsx (add navigation button at bottom)

Page structure (Resend-style):
- Header: "Senders" with "+ Add sender" button (top right)
- SenderTable component
- AddSenderDialog (opens on button click)
```

### Verification Plan for Story 1

| Step | Action | Expected Result | Pass Criteria |
|------|--------|-----------------|---------------|
| V1.1 | Run database migration | Migration completes | `senders` table exists in Supabase |
| V1.2 | Navigate to Senders page | Page loads with Resend-style layout | See "Senders" header and "+ Add sender" button |
| V1.3 | Click "+ Add sender" button | Step 1 dialog opens | See "Which email address you prefer to use?" header |
| V1.4 | Enter invalid email (e.g., "not-an-email") | Validation error shown | Cannot proceed to Step 2 |
| V1.5 | Enter valid email (e.g., "user@example.com") | Proceed to Step 2 | See DNS records display for Cloudflare |
| V1.6 | Check AWS SES Console | Domain identity created | See "example.com" domain in SES Identities |
| V1.7 | View DNS records in Step 2 | Records displayed | See TXT verification record and 3 DKIM CNAME records |
| V1.8 | Click copy button on DNS record | Value copied to clipboard | Can paste value into Cloudflare |
| V1.9 | Close dialog and check table | Sender appears in table | Shows email, "Pending" status, created timestamp |
| V1.10 | Verify API returns correct data | GET /api/senders returns list | Response includes sender with all fields |
| V1.11 | Try to add same email again | Error shown | "Sender already exists" message |
| V1.12 | Delete sender via action menu | Confirmation, then removed | Sender removed from table and SES |
| V1.13 | Check navigation from Analytics | Button works | Can navigate to Senders page from Analytics |

---

## User Story 2: Verification of Users' Inputs

### Tasks

**2.1 Verification Check API**
- `src/app/api/domains/[id]/verify/route.ts` - POST to trigger verification check
- Calls AWS SES to check domain and DKIM status
- Updates database with current status

**2.2 Verification Status Component**
- `src/components/domains/VerificationStatus.tsx`
- Badge component showing: pending (yellow), verified (green), failed (red)
- Tooltip with details and timestamp

**2.3 DNS Records Display Enhancement**
- Show all required records with copy-to-clipboard:
  - Domain verification TXT record: `_amazonses.{domain}`
  - 3 DKIM CNAME records: `{token}._domainkey.{domain}`
  - SPF TXT record (recommended)
- Per-record status indicator (pending/verified)

**2.4 Background Verification Job**
- `src/lib/inngest/functions/check-domain-verification.ts`
- Periodic check of pending domains (every 2-4 hours)
- Update status automatically when DNS records are configured

**2.5 Set Default Domain API**
- `src/app/api/domains/[id]/set-default/route.ts` - POST

### Detailed Implementation Plan for Story 2

#### Step 2.1: Verification Check API (Est. file changes: 1)
```
Files to create:
- src/app/api/domains/[id]/verify/route.ts

Route: POST /api/domains/[id]/verify
Logic:
1. Auth check, get organization_id
2. Fetch domain from DB, verify ownership
3. Check rate limit (30-second cooldown per domain)
4. Call sesService.getIdentityVerificationAttributes([domain])
5. Call sesService.getIdentityDkimAttributes([domain])
6. Map SES response to status:
   - VerificationStatus: 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure' | 'NotStarted'
   - DkimStatus: same values
7. Update database with new status
8. Return updated domain with status

Response structure:
{
  domain: SenderDomain,
  dnsRecords: DnsRecord[],
  verificationDetails: {
    domainStatus: string,
    dkimStatus: string,
    lastCheckedAt: string,
    isFullyVerified: boolean
  }
}
```

#### Step 2.2: Verification Status Component (Est. file changes: 1)
```
Files to create:
- src/components/domains/VerificationStatus.tsx

Component props:
interface VerificationStatusProps {
  status: 'pending' | 'verifying' | 'verified' | 'failed';
  dkimStatus?: 'pending' | 'success' | 'failed' | 'not_started';
  lastVerifiedAt?: Date;
  error?: string;
}

Badge variants:
- pending: yellow background, clock icon
- verifying: blue background, spinner icon
- verified: green background, check icon
- failed: red background, x icon

Tooltip content:
- Status description
- DKIM status if applicable
- Last check timestamp
- Error message if failed
```

#### Step 2.3: DNS Records Status Enhancement (Est. file changes: 1)
```
Files to modify:
- src/components/domains/DnsRecordsTable.tsx

Enhance existing component:
- Add 'verified' column with checkmark/pending indicator
- Query actual DNS (optional, can use SES status)
- Show SPF record as "Recommended" not required
- Add help text explaining each record type

Record status logic:
- Domain TXT: verified if verificationStatus === 'verified'
- DKIM CNAMEs: verified if dkimStatus === 'success'
- SPF: display as recommendation, no status check
```

#### Step 2.4: Background Verification Job (Est. file changes: 2)
```
Files to create:
- src/lib/inngest/functions/check-domain-verification.ts

Files to modify:
- src/lib/inngest/client.ts (register new function)

Inngest function definition:
export const checkDomainVerification = inngest.createFunction(
  { id: 'check-domain-verification', name: 'Check Domain Verification Status' },
  { cron: '0 */4 * * *' }, // Every 4 hours
  async ({ step }) => {
    // 1. Fetch all domains with status 'pending' or 'verifying'
    const pendingDomains = await step.run('fetch-pending-domains', async () => {
      return db.select().from(senderDomains)
        .where(or(
          eq(senderDomains.verificationStatus, 'pending'),
          eq(senderDomains.verificationStatus, 'verifying')
        ));
    });

    // 2. Check each domain in batches of 10
    for (const batch of chunk(pendingDomains, 10)) {
      await step.run(`check-batch-${batch[0].id}`, async () => {
        const domains = batch.map(d => d.domain);
        const verificationAttrs = await sesService.getIdentityVerificationAttributes(domains);
        const dkimAttrs = await sesService.getIdentityDkimAttributes(domains);

        // 3. Update database for each domain
        for (const domain of batch) {
          const verification = verificationAttrs.get(domain.domain);
          const dkim = dkimAttrs.get(domain.domain);

          await db.update(senderDomains)
            .set({
              verificationStatus: mapSesStatus(verification?.VerificationStatus),
              dkimStatus: mapDkimStatus(dkim?.DkimVerificationStatus),
              lastVerifiedAt: new Date(),
              updatedAt: new Date(),
            })
            .where(eq(senderDomains.id, domain.id));
        }
      });

      // Small delay between batches
      await step.sleep('batch-delay', '2s');
    }

    return { checkedCount: pendingDomains.length };
  }
);
```

#### Step 2.5: Set Default Domain API (Est. file changes: 1)
```
Files to create:
- src/app/api/domains/[id]/set-default/route.ts

Route: POST /api/domains/[id]/set-default
Logic:
1. Auth check, get organization_id
2. Fetch domain, verify ownership
3. Verify domain is fully verified (verificationStatus === 'verified' && dkimStatus === 'success')
4. Transaction:
   a. Set all org domains is_default = false
   b. Set target domain is_default = true
5. Return updated domain

Error cases:
- Domain not found: 404
- Domain not owned by org: 403
- Domain not verified: 400 "Domain must be verified before setting as default"
```

### Verification Plan for Story 2

| Step | Action | Expected Result | Pass Criteria |
|------|--------|-----------------|---------------|
| V2.1 | Add domain and click "Verify" immediately | Status shows "Pending" | No error, status unchanged (DNS not configured yet) |
| V2.2 | Configure DNS TXT record at registrar | Record propagates | Can verify via dig or nslookup |
| V2.3 | Click "Verify" button after DNS configured | Status updates | Domain status changes to "Verified" |
| V2.4 | Configure DKIM CNAME records | Records propagate | Can verify via dig |
| V2.5 | Click "Verify" again | DKIM status updates | DKIM shows "Success" |
| V2.6 | Check verification status badge | Shows green "Verified" | Tooltip shows full details |
| V2.7 | Wait for background job (or trigger manually) | Pending domains checked | Database updated, logs show check ran |
| V2.8 | Try to set unverified domain as default | Error shown | "Domain must be verified" message |
| V2.9 | Set verified domain as default | Success | Domain shows "Default" badge |
| V2.10 | Add another domain and set as default | Previous default unset | Only one default per org |
| V2.11 | Check rate limiting on verify | Cooldown enforced | Cannot spam verify button (30s cooldown) |

---

## User Story 3: Sending Generated Emails via AWS SES

### Tasks

**3.1 Email Provider Interface**
- New file: `src/lib/email/provider-factory.ts`
- Define `EmailProvider` interface with `sendEmail()` method
- Factory to select provider based on organization's verified domain

**3.2 SES Email Provider**
- New file: `src/lib/email/providers/ses-provider.ts`
- Implements `EmailProvider` interface
- Uses SES `SendEmail` command
- Handles SES-specific rate limits (14 emails/sec default)

**3.3 Resend Email Provider (Wrapper)**
- New file: `src/lib/email/providers/resend-provider.ts`
- Wrap existing `src/lib/email/resend.ts` logic
- Implements `EmailProvider` interface

**3.4 Modify Email Sending Flow**
- Update: `src/lib/inngest/functions/send-emails.ts`
- Use provider factory to get appropriate provider
- Check for verified domain, fallback to Resend if none
- Track which provider was used in campaign_items

**3.5 SES Webhook Handler (Optional)**
- `src/app/api/webhooks/ses-events/route.ts`
- Handle bounce/complaint SNS notifications
- Update suppression list

### Detailed Implementation Plan for Story 3

#### Step 3.1: Email Provider Interface (Est. file changes: 1)
```
Files to create:
- src/lib/email/provider-factory.ts

Interface definitions:
export interface EmailOptions {
  to: string;
  from: string;
  fromName?: string;
  subject: string;
  html: string;
  replyTo?: string;
  headers?: Record<string, string>;
  tags?: Record<string, string>;
  organizationId: string;
  campaignId?: number;
}

export interface EmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
  provider: 'ses' | 'resend';
}

export interface EmailProvider {
  sendEmail(options: EmailOptions): Promise<EmailResult>;
  sendBulkEmails?(options: EmailOptions[]): Promise<EmailResult[]>;
  getProviderName(): 'ses' | 'resend';
  getRateLimits(): { maxPerSecond: number; batchSize: number };
}

export interface RateLimitConfig {
  maxPerSecond: number;
  batchSize: number;
  delayBetweenBatches: number;
}

Factory class:
export class EmailProviderFactory {
  // Get the appropriate provider for an organization
  async getProvider(organizationId: string): Promise<EmailProvider> {
    // 1. Check for verified default domain
    const defaultDomain = await db.select()
      .from(senderDomains)
      .where(and(
        eq(senderDomains.organizationId, organizationId),
        eq(senderDomains.isDefault, true),
        eq(senderDomains.verificationStatus, 'verified'),
        eq(senderDomains.dkimStatus, 'success')
      ))
      .limit(1);

    // 2. If verified domain exists, return SES provider
    if (defaultDomain.length > 0) {
      return new SESEmailProvider(defaultDomain[0]);
    }

    // 3. Otherwise, return Resend provider
    return new ResendEmailProvider();
  }

  async hasVerifiedDomain(organizationId: string): Promise<boolean> { ... }
}

export const emailProviderFactory = new EmailProviderFactory();
```

#### Step 3.2: SES Email Provider (Est. file changes: 1)
```
Files to create:
- src/lib/email/providers/ses-provider.ts

Class implementation:
export class SESEmailProvider implements EmailProvider {
  private sesService: SESService;
  private domain: SenderDomain;

  constructor(domain: SenderDomain) {
    this.domain = domain;
    this.sesService = new SESService(domain.region);
  }

  async sendEmail(options: EmailOptions): Promise<EmailResult> {
    try {
      // Validate sender domain matches verified domain
      const senderDomain = options.from.split('@')[1];
      if (senderDomain !== this.domain.domain) {
        throw new Error(`Sender domain ${senderDomain} does not match verified domain ${this.domain.domain}`);
      }

      const command = new SendEmailCommand({
        Source: options.fromName
          ? `${options.fromName} <${options.from}>`
          : options.from,
        Destination: {
          ToAddresses: [options.to],
        },
        Message: {
          Subject: { Data: options.subject },
          Body: { Html: { Data: options.html } },
        },
        ReplyToAddresses: options.replyTo ? [options.replyTo] : undefined,
        ConfigurationSetName: this.domain.configurationSetName || undefined,
        Tags: options.tags
          ? Object.entries(options.tags).map(([Name, Value]) => ({ Name, Value }))
          : undefined,
      });

      const response = await this.sesService.client.send(command);

      return {
        success: true,
        messageId: response.MessageId,
        provider: 'ses',
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        provider: 'ses',
      };
    }
  }

  getProviderName(): 'ses' { return 'ses'; }

  getRateLimits(): RateLimitConfig {
    // SES sandbox: 1/sec, production: 14/sec default (can be higher)
    return {
      maxPerSecond: 14,
      batchSize: 10,
      delayBetweenBatches: 800, // ms
    };
  }
}
```

#### Step 3.3: Resend Email Provider (Est. file changes: 1)
```
Files to create:
- src/lib/email/providers/resend-provider.ts

Wrap existing Resend logic:
import { sendEmail as resendSendEmail } from '@/lib/email/resend';

export class ResendEmailProvider implements EmailProvider {
  async sendEmail(options: EmailOptions): Promise<EmailResult> {
    try {
      const result = await resendSendEmail({
        to: options.to,
        from: options.from,
        fromName: options.fromName,
        subject: options.subject,
        html: options.html,
        replyTo: options.replyTo,
        tags: {
          campaign_id: options.campaignId?.toString() || '',
          organization_id: options.organizationId,
        },
      });

      return {
        success: true,
        messageId: result.id,
        provider: 'resend',
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        provider: 'resend',
      };
    }
  }

  getProviderName(): 'resend' { return 'resend'; }

  getRateLimits(): RateLimitConfig {
    return {
      maxPerSecond: 2,
      batchSize: 10,
      delayBetweenBatches: 600, // ms (existing behavior)
    };
  }
}
```

#### Step 3.4: Modify Email Sending Flow (Est. file changes: 2)
```
Files to modify:
- src/lib/inngest/functions/send-emails.ts
- src/lib/db/schema.ts (add provider_used column to campaign_items)

Schema change:
// Add to campaign_items table
providerUsed: varchar('provider_used', { length: 20 }), // 'ses' or 'resend'

Send function changes:
// At the start of sendCampaignBatch function:
const provider = await emailProviderFactory.getProvider(campaign.organizationId);
const rateLimits = provider.getRateLimits();

// Modify the sending loop:
for (const item of itemsToSend) {
  // ... existing suppression check ...

  // Use provider instead of direct Resend call
  const result = await provider.sendEmail({
    to: recipientEmail,
    from: campaign.senderEmail,
    fromName: campaign.senderName,
    subject: item.emailSubject,
    html: emailWithTracking,
    organizationId: campaign.organizationId,
    campaignId: campaign.id,
  });

  if (result.success) {
    await db.update(campaignItems)
      .set({
        status: 'sent',
        messageId: result.messageId,
        providerUsed: result.provider,
        sentAt: new Date(),
      })
      .where(eq(campaignItems.id, item.id));
    sentCount++;
  } else {
    // ... existing error handling ...
  }

  // Use provider-specific rate limit
  await sleep(rateLimits.delayBetweenBatches);
}
```

#### Step 3.5: SES Webhook Handler (Est. file changes: 1)
```
Files to create:
- src/app/api/webhooks/ses-events/route.ts

Handle SNS notifications for SES events:
export async function POST(request: NextRequest) {
  const body = await request.json();

  // Handle SNS subscription confirmation
  if (body.Type === 'SubscriptionConfirmation') {
    await fetch(body.SubscribeURL);
    return NextResponse.json({ status: 'confirmed' });
  }

  // Handle notification
  if (body.Type === 'Notification') {
    const message = JSON.parse(body.Message);
    const eventType = message.eventType; // 'Bounce' | 'Complaint' | 'Delivery'

    if (eventType === 'Bounce') {
      const bounceType = message.bounce.bounceType; // 'Permanent' | 'Transient'
      const recipients = message.bounce.bouncedRecipients;

      for (const recipient of recipients) {
        // Add to suppression list
        await db.insert(suppressionList).values({
          organizationId: extractOrgIdFromTags(message.mail.tags),
          email: recipient.emailAddress,
          type: bounceType === 'Permanent' ? 'bounced' : 'bounced',
          reason: message.bounce.bounceSubType,
          campaignId: extractCampaignIdFromTags(message.mail.tags),
        });

        // Record event
        await db.insert(emailEvents).values({
          organizationId: extractOrgIdFromTags(message.mail.tags),
          campaignId: extractCampaignIdFromTags(message.mail.tags),
          eventType: 'bounced',
          eventData: message.bounce,
          occurredAt: new Date(message.mail.timestamp),
        });
      }
    }

    if (eventType === 'Complaint') {
      // Similar handling for complaints
    }
  }

  return NextResponse.json({ status: 'processed' });
}
```

### Verification Plan for Story 3

| Step | Action | Expected Result | Pass Criteria |
|------|--------|-----------------|---------------|
| V3.1 | Create campaign without verified domain | Uses Resend provider | Email sent via Resend, providerUsed = 'resend' |
| V3.2 | Add and verify a domain for organization | Domain verified | Domain shows as verified in settings |
| V3.3 | Set verified domain as default | Success | Domain marked as default |
| V3.4 | Create campaign with sender email matching verified domain | Uses SES provider | Email sent via SES, providerUsed = 'ses' |
| V3.5 | Check AWS SES Console after sending | Email logged | See email in SES sending statistics |
| V3.6 | Create campaign with non-matching sender domain | Falls back to Resend | providerUsed = 'resend', warning shown |
| V3.7 | Send batch of 50 emails via SES | Rate limiting works | Emails sent with appropriate delays |
| V3.8 | Check campaign_items table | Provider tracked | providerUsed column populated correctly |
| V3.9 | Trigger bounce event (test email) | Suppression list updated | Bounced email added to suppression |
| V3.10 | Try to send to suppressed email | Email skipped | Status = 'suppressed', not sent |
| V3.11 | Check email tracking works | Events recorded | Opens/clicks recorded in email_events |
| V3.12 | Remove default domain during active campaign | Graceful handling | Campaign continues with fallback or clear error |

---

## Environment Variables Required

```env
AWS_ACCESS_KEY_ID=xxx
AWS_SECRET_ACCESS_KEY=xxx
AWS_SES_REGION=ap-southeast-1
```

---

## DNS Records Reference (Display to Users)

| Purpose | Type | Name | Value |
|---------|------|------|-------|
| Domain Verify | TXT | `_amazonses.{domain}` | `{verification_token}` |
| DKIM 1 | CNAME | `{token1}._domainkey.{domain}` | `{token1}.dkim.amazonses.com` |
| DKIM 2 | CNAME | `{token2}._domainkey.{domain}` | `{token2}.dkim.amazonses.com` |
| DKIM 3 | CNAME | `{token3}._domainkey.{domain}` | `{token3}.dkim.amazonses.com` |
| SPF | TXT | `{domain}` | `v=spf1 include:amazonses.com ~all` |

---

## Key Files to Modify/Create

| File | Action | Purpose |
|------|--------|---------|
| `src/lib/db/schema.ts` | Modify | Add sender_domains table, add providerUsed to campaign_items |
| `src/lib/email/ses.ts` | Create | AWS SES client wrapper |
| `src/lib/services/domain-verification.ts` | Create | Domain management service |
| `src/lib/email/provider-factory.ts` | Create | Provider selection logic |
| `src/lib/email/providers/ses-provider.ts` | Create | SES email sending |
| `src/lib/email/providers/resend-provider.ts` | Create | Resend wrapper |
| `src/lib/inngest/functions/send-emails.ts` | Modify | Use provider factory |
| `src/lib/inngest/functions/check-domain-verification.ts` | Create | Auto-verify pending domains |
| `src/app/api/domains/*` | Create | API routes |
| `src/app/api/webhooks/ses-events/route.ts` | Create | SES event webhook |
| `src/app/(dashboard)/settings/domains/page.tsx` | Create | Domain settings UI |
| `src/components/domains/*` | Create | UI components |

---

## Existing Patterns to Reuse

- **Form validation:** Zod + React Hook Form (see `src/components/campaigns/CampaignForm.tsx`)
- **UI components:** Card, Dialog, Button, Input from `src/components/ui/`
- **Settings layout:** Follow `src/app/(dashboard)/settings/page.tsx` pattern
- **Multi-tenancy:** Use `organization_id` filtering (see `src/lib/db/tenant.ts`)
- **Background jobs:** Inngest patterns from `src/lib/inngest/functions/`

---

## Implementation Order

1. Database schema and migration (foundation)
2. AWS SES service (core integration)
3. Domain verification service (business logic)
4. API routes (backend complete)
5. UI components and settings page (user-facing)
6. Provider factory and email sending modification (final integration)
7. Background verification job
8. SES webhook handler (optional, for bounce/complaint tracking)

---

## Summary of Estimated Changes

| Story | New Files | Modified Files | Total |
|-------|-----------|----------------|-------|
| Story 1 | 7 | 2 | 9 |
| Story 2 | 3 | 2 | 5 |
| Story 3 | 4 | 2 | 6 |
| **Total** | **14** | **6** | **20** |

---

## Potential Issues and Mitigations

### Issue 1: AWS SES Sandbox Mode
**Problem:** New AWS SES accounts are in sandbox mode, limiting sending to verified email addresses only (max 200 emails/day, 1 email/sec).
**Mitigation:**
- Check SES account status via `GetAccountSendingEnabled` API
- Display warning in UI if in sandbox mode
- Provide documentation link for requesting production access
- Handle quota limits gracefully with clear user messaging

### Issue 2: DNS Propagation Delay
**Problem:** DNS changes can take 24-72 hours to propagate globally.
**Mitigation:**
- Show clear messaging: "DNS verification can take up to 72 hours"
- Add "Check Again" button with 30-second cooldown
- Background job checks every 4 hours automatically
- Store and display last check timestamp

### Issue 3: Domain Ownership & Security
**Problem:** Preventing users from claiming domains they don't own or malicious domains.
**Mitigation:**
- DNS TXT record verification inherently proves ownership
- Validate domain format (no IP addresses, no localhost)
- Blacklist common test domains (example.com, test.com)
- Rate limit domain additions (max 5 pending domains per organization)

### Issue 4: Rate Limiting Differences
**Problem:** AWS SES (1-14+ emails/sec based on account) vs Resend (2 req/sec) have different limits.
**Mitigation:**
- Store provider-specific rate limits in provider config
- Query SES sending quota via `GetSendQuota` API
- Adjust batch delays dynamically based on provider
- Track usage per provider separately

### Issue 5: Campaign-Domain Consistency
**Problem:** Campaign sender email must match a verified domain.
**Mitigation:**
- Validate sender email domain against verified domains during campaign creation
- Allow Resend default domain for organizations without verified domains
- Show domain status in campaign creation UI

### Issue 6: SES Event Tracking
**Problem:** SES requires Configuration Sets for tracking opens/clicks/bounces.
**Mitigation:**
- Create organization-specific Configuration Set when first domain is verified
- Configure SNS topics for bounce/complaint notifications
- Map SES events to existing email_events table structure

### Issue 7: Concurrent Operations
**Problem:** Multiple verify clicks or domain operations can cause race conditions.
**Mitigation:**
- Add loading states and disable buttons during API calls
- Implement optimistic locking on domain status updates
- Rate limit verify endpoint (1 request per domain per 30 seconds)

### Issue 8: Domain Deletion Safety
**Problem:** Deleting a domain while campaigns are sending could break email delivery.
**Mitigation:**
- Check for active campaigns using the domain before deletion
- Soft-delete with grace period (7 days) before hard delete
- Require explicit confirmation for deletion

## Follow-up 1: User Story 1 Implementation (06 FEB 2026)

### Focus: Allow User to Input Required DNS Details

**Implementation Order:**
1. Database Schema - Add `senders` table
2. AWS SES Service - Create SES client wrapper
3. Sender Verification Service - Business logic
4. API Routes - `/api/senders` endpoints
5. UI Components - Senders page and Add Sender dialog
6. Navigation - Button from Analytics page

**Key Files to Create:**
- `src/lib/db/schema.ts` (modify) - Add senders table
- `src/lib/db/migrations/XXXX_add_senders.sql` (new)
- `src/lib/email/ses.ts` (new) - AWS SES client
- `src/lib/services/sender-verification.ts` (new)
- `src/app/api/senders/route.ts` (new)
- `src/app/api/senders/[id]/route.ts` (new)
- `src/app/(dashboard)/senders/page.tsx` (new)
- `src/components/senders/SenderTable.tsx` (new)
- `src/components/senders/AddSenderDialog.tsx` (new)
- `src/components/senders/DnsRecordsDisplay.tsx` (new)

**UI Design:**
- Senders page with Resend-style table layout
- 2-step onboarding: Email input → DNS records display
- Table columns: Email Address | Status | Created | Actions

## Follow-up 2: The build succeeded. All tasks for User Story 1 are now complete.
 ● User Story 1 Implementation Complete

 Here's a summary of what was built:
 
 Database & Schema:
  - Added senders table to src/lib/db/schema.ts
  - Created migration file src/lib/db/migrations/1770508800000_add_senders.sql

  Backend Services:
  - src/lib/email/ses.ts - AWS SES client wrapper (domain verification, DKIM, email sending)
  - src/lib/services/sender-verification.ts - Business logic for sender management

  API Routes:
  - GET /api/senders - List all senders
  - POST /api/senders - Add new sender (triggers AWS SES verification)
  - GET /api/senders/[id] - Get sender with DNS records
  - DELETE /api/senders/[id] - Delete sender
  - POST /api/senders/[id]/verify - Check verification status
  - POST /api/senders/[id]/set-default - Set as default sender

  UI Components:
  - src/components/senders/SenderTable.tsx - Resend-style table with actions dropdown
  - src/components/senders/AddSenderDialog.tsx - 2-step onboarding flow
  - src/components/senders/DnsRecordsDisplay.tsx - DNS records with copy-to-clipboard
  - src/components/ui/dropdown-menu.tsx - Radix dropdown menu component

  Pages:
  - src/app/(dashboard)/senders/page.tsx - Main Senders management page
  - Added navigation button to Analytics page

  Dependencies Added:
  - sonner (toast notifications)
  - date-fns (date formatting)
  - @radix-ui/react-dropdown-menu

  The Senders page is now accessible at /senders and includes the full flow for adding email senders with AWS SES domain verification.
